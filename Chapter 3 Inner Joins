/*
前面的章节都是只选择了一张表格
这一章模拟的是应用多张表格
*/
# 3.1 Inner Join 内连接
-- 这一课教的是连接两个表格的方法
-- 这里的应用是选取orders和customers的customer_id并连接
-- 以此得到同一个顾客下的不同订单
SELECT order_id, o.customer_id, first_name, last_name
-- 这里要指定customer_id来自于哪个表，因为两个表都有此列
-- 不指明的话会报错‘ambiguous’
FROM sql_store.orders AS o -- AS可以省略
INNER JOIN customers AS c -- AS可以省略, INNER也可以省略
		ON o.customer_id = c.customer_id

# 练习3.1
-- 	对照order items表，和products表连接
-- 每笔订单都返回订单id，产品id和名字，连同order items表的数量和单价
SELECT  order_id, oi.product_id, name, quantity, oi.unit_price -- order_id仅在oi表出现，无需指定
FROM order_items AS oi
INNER JOIN products AS pd
	ON oi.product_id = pd.product_id
-- 简洁版：
SELECT order_id, oi.product_id, name, quantity, oi.unit_price
FROM order_items oi
JOIN products p
  ON oi.product_id = p.product_id

# 3.2 Joining Across Databases 跨数据库连接
-- 假设要将(1)sql_store的order_items表
-- 和(2)sql_inventory的products表连接
USE sql_store; 
SELECT *
FROM order_items oi
-- 因为在课程开始选择的就是sql_store的数据库
-- 所以第一行order_item不用指定数据库
-- 只需要给不在当前数据库的表加前缀
JOIN sql_inventory.products p
	ON oi.product_id = p.product_id

# 3.3 Self Joins
-- 将一个表自己连接自己称之为自连接
-- 和内连接操作大抵相同
-- 只是需要注意给表添加不同别称即可
USE sql_hr; 

SELECT 
	e.employee_id, 
    	e.first_name AS employee, 
--    	e.last_name, 
--    	e.job_title, 
--    	e.reports_to, 
    	m.first_name AS manager
FROM employees e
JOIN employees m
	ON e.reports_to = m.employee_id

# 3.4 Joining Multiple Tables
-- 为了制造一个简洁的包含订单id，用户姓名以及订单状态的表格
-- 需要连接来自customers的姓名，orders的order_id, order_statues的状态
-- 自己先写一遍！
USE sql_store; 

SELECT order_id, order_date, c.first_name, c.last_name, os.name
FROM orders o
JOIN customers c
	ON c.customer_id = o.customer_id
JOIN order_statuses os
	ON o.status = os.order_status_id
ORDER BY name, order_id

-- 老师写的：
SELECT 
	order_id, 
    order_date, 
    c.first_name, 
    c.last_name, 
    os.name AS status
FROM orders o
JOIN customers c
	ON c.customer_id = o.customer_id
JOIN order_statuses os
	ON o.status = os.order_status_id
ORDER BY name, order_id

# 练习3.4
-- 从sql_invoicing连接必要的表格
-- 制造一张含有顾客姓名，付款方式，日期的表格
-- 因为题目没有明确需求，自己发挥选择什么列来制造表格

USE sql_invoicing; 

SELECT 
 	p.payment_id, 
--	p.invoice_id
    p.date, 
    c.name AS client_name, 
    p.amount, 
    pm.name AS payment_method
FROM payments p
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id
JOIN clients c
	ON p.client_id = c.client_id

# 3.5 Compound Join Conditions 复合连接条件
-- 当一个表有两个主键时，比如order_items的主键是产品id和订单id
-- 这时候就要用到复合连接
-- 基本就是在之前学过的连接加一个AND条件。
-- 这里记得按照视频改order_item_notes的数据
USE sql_store;

SELECT *
FROM order_items oi
JOIN order_item_notes oin
	ON oi.order_id = oin.order_id
    AND oi.product_id = oin.product_id

# 3.6 Implicit Join Syntax 隐式连接语法
SELECT *
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id
-- 上述是之前学过的连接语法，也是比较常见的 
-- 下面是隐式连接的一个例子，和上面等效
-- 但是不建议用，因为如果忘记WHERE子句，就会得到交叉连接的结果
-- （似乎又称笛卡尔积/笛卡尔爆炸？
SELECT *
FROM orders o, customers c
WHERE    o.customer_id = c.customer_id

# 3.7 Outer Joins 外连接
-- 先回顾一个内连接的简单例子：
SELECT 
	c.customer_id, 
    c.first_name, 
    o.order_id
FROM customers c
JOIN orders o
	ON c.customer_id = o.customer_id -- 代表着在orders下了单的customers的顾客
    -- 不会显示没下订单的顾客
    -- 简称：交集
ORDER BY c.customer_id 

-- 外连接有两种类型: Left Join & Right Join
-- Left Join代表所有左（上FROM）表的所有记录都会被返回，无论是否符合条件
-- 在此例中会返回所有顾客
-- Right Join 同理，在此例中会返回所有订单
-- LEFT/RIGHT (OUTER) JOIN，这里OUTER可有可无，和INNER一样

/*
总结：只写JOIN，内连接；加LEFT/RIGHT, 外连接；OUTER/INNER可忽略
*/

# 练习3.7
-- 这个练习是外连接products和order_items表
SELECT 
	p.product_id, 
    p.name, 
    oi.quantity
FROM products p
LEFT JOIN order_items oi
	ON p.product_id = oi.product_id
ORDER BY product_id
